#include <stdio.h>
#include "sss.h"

/*
31547 111101100111011 15773
16
1000000000000001=11*111*11001 H
=11010001
1000000000000001=10011*11111 G
=111010001
[15,7,5]-BCH Code
*/



typedef unsigned long long int poly;
poly quo,quo_low,res,res_low;

#define MSB (~(~0UL>>1))
#define N 16
unsigned char gf[N] = {0, 1, 2, 4, 8, 3, 6, 12, 11, 5, 10, 7, 14, 15, 13, 9};

unsigned int mlt();

static char *G[7]={
  "100010111000000",
  "010001011100000",
  "001000101110000",
  "000100010111000",
  "000010001011100",
  "000001000101110",
  "000000100010111"
},
  Ht[8]={
    0b000000011010001,
    0b000000110100010,
    0b000001101000100,
    0b000011010001000,
    0b000110100010000,
    0b001101000100000,
    0b011010001000000,
    0b110100010000000
  }, m='R';

static char *GT[15]={
  "1000000","0100000","0010000","0001000","1000100","0100010","1010001",
  "1101000","1110100","0111010","0011101","0001110","0000111","0000011",
  "0000001"
};
	*H2[8]={
	  "100010011010111",
	  "010011010111100",
	  "001001101011110",
	  "000100110101111",
	  "100011000110001",
	  "000110001100011",
	  "001010010100101",
	  "011110111101111"
	},
	  *r2[3]={
	    "110000000000000",
	    "110111101011000",
	    "101010010110000"
	  };

static int z1[15]={
  0b1,0b10,0b100,0b1000,0b10000,0b100000,0b1000000,0b10000000,0b100000000,
  0b1000000000,0b10000000000,0b100000000000,0b1000000000000,0b10000000000000,
  0b100000000000000
};

static int z2[104]={
  3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68
  ,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288
  ,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040
  ,1056,1088,1152,1280,1536,2049,2050,2052
  ,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112
  ,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320
  ,8448,8704,9216,10240,12288,16385,16386,16388
  ,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576
},

*z3[455]={};

v[7]={ /* unit vector */
  0b1000000,
  0b0100000,
  0b0010000,
  0b0001000,
  0b0000100,
  0b0000010,
  0b0000001
};



main(){
  char u[30],buf[128];
  int c,i,j,d[8],g,h,e[8][104],k,l,x='R';
  FILE *fp,*fo;
  

  fp=fopen("4.gz","rb");
  fo=fopen("mcl.crp","wb");
  
  h=0b11010001;
  g=0b111010001;
  
/* mz(); */
  syn(); 
/* genz(); */
/* ve(); */

/*
  for(i=0;i<15;i++){
  l=strtoul(GT[i],(char **)NULL,2);
  printf("%d",itob(x&l,u)%2);
}
*/

/*
d[0]=0b1010010;
d[1]=0b0010010;
d[2]=0b1110010;
d[3]=0b1000010;
d[4]=0b1011010;
d[5]=0b1010110;
d[6]=0b1010000;
d[7]=0b1010011;
for(i=0;i<8;i++){
for(j=0;j<15;j++)
printf("%d",itob(d[i]&strtoul(GT[j],(char **)NULL,2),u)%2);
printf("\n");
}


d[0]=0b101011010011110;
d[1]=0b001001101011110;
d[2]=0b111010001111110;
d[3]=0b100011111101110;
d[4]=0b101111000100110;
d[5]=0b101001011000010;
d[6]=0b101010010110000;
d[7]=0b101011110001001;
for(i=0;i<8;i++)
printf("%b\n",d[0]^d[i]);
for(i=0;i<7;i++)
printf("%b\n",strtoul(G[i],(char **)NULL,2));
*/

/*
for(i=0;i<8;i++){
for(j=0;j<104;j++)
e[i][j]=d[i]^z2[j];
}
for(i=0;i<8;i++){
for(k=0;k<104;k++){
for(j=0;j<104;j++)
printf("%d,",itob(e[i][j]^e[i][k],u));
printf("\n");
}
printf("\n");
}
*/

/*
for(i=0;i<15;i++){
l=strtoul(GT[i],(char **)NULL,2);
printf("%d",itob(m&l,u)%2);
}
printf("\n");


for(j=0;j<15;j++){
for(i=0;i<8;i++){
l=strtoul(Ht[i],(char **)NULL,2);


printf("%d",itob(0b101011010011110&l,u)%2); 
printf("%d",itob((strtoul(G[0],(char **)NULL,2)^z1[j])&l,u)%2);
}
printf("\n");
}


for(j=0;j<7;j++){
h=strtoul(G[j],(char **)NULL,2);
for(i=0;i<8;i++){
g=strtoul(H2[i],(char **)NULL,2);
printf("%d",itob(g&h,u)%2);
}
printf("\n");

}
*/

/* printf("%b\n",x); */

/*
for(i=0;i<29;i++){
e[0][i]=z[i]^0b001001101011110;
e[1][i]=z[i]^0b111010001111110;
e[2][i]=z[i]^0b100011111101110;
e[3][i]=z[i]^0b101111000100110;
e[4][i]=z[i]^0b101001011000010;
e[5][i]=z[i]^0b101010010110000;
e[6][i]=z[i]^0b101011110001001;
}

for(j=0;j<7;j++){
for(i=0;i<29;i++){
for(k=0;k<29;k++)
printf("%u ",itob(e[j][i]^e[j][k],u));
printf("\n");
}
printf("\n");
}



for(i=0;i<7;i++)
u[i]=m^v[i];
for(i=0;i<7;i++){
for(j=0;j<15;j++)
printf("%u",we(u[i]&GT[j]));
printf("\n");
}

}





void mz()
{
int i,j,k;
char t[15];


for(i=0;i<0b111111111111111;i++){
if(itob(i,t)==2)
printf("%u\n,",i);
}

}


/* weight parity */
int we(int a)
{
char t[23];
int l;


l=itob(a,t);
return l%2;

}


/* ベクトルの重み計算 */
int itob(int n,char s[])
{
int i,j,k=0;

for(i=15,j=0;i>=0;i--,j++){
s[j]=((n>>i) & 0x0001) + '0';
}

for(j=0;j<16;j++){
if(s[j]-48==1)
k++;
}
return k;

}



/* ２の拡大体上での乗算 */
unsigned int mlt(unsigned int x,unsigned int y)
{
    if(x==0||y==0){
        return(0);
    }
    return ((x+y-2)%(N-1))+1;
}


/* F_2 上の多項式の積 */
int seki(unsigned int a,unsigned int b)
{
unsigned int c;

c=0;
while(a!=0){
if (a & 1) c^=b;
b<<=1; a>>=1;
}
return c;
}


/* F_2 上の多項式の割り算 */
unsigned int pd(unsigned int p,unsigned int d)
{
unsigned int x,y,r,q,i,j;

q=p; y=d;
r=0;
i=cb(q)-cb(y);
y=(y<<i);

while(y > 0){
if(cb(q)==cb(y)){
r=r + (1<<i);
printf("fi%b %b\n",q,y);
q=(q^y);
printf("if%b %b\n",q,y);
	}
y=d;
i=cb(q)-cb(y);
y=(y<<i);
}
return q;
/* printf("%b %b\n",r,q); */

}


/* 何ビット整数か返す */
short cb(unsigned int x)
{
int i,j;

i=0;
while(x>0){
x=(x>>1); i++;
}
return i;

}


/* シンドローム計算 */
void syn()
{
int i,j,n,k,l,syn[256],count=0;
char r[16];



scanf("%d",&n);
srand(n);
for(i=0;i<256;i++)
syn[i]=0;

for(;;){
	k= rand(n)%65536;l=0;
	for(i=0;i<8;i++)
		l=(l<<1)+(itob(Ht[i]&k,r)%2);
	if(l<256){
		if(syn[l]==0){
			syn[l]=k;
			count++;
		}
	}
	if(count==256){
		for(i=0;i<256;i++)
			printf("%d %d %d\n",i,syn[i],itob(k,r));
		exit(1);
	}

}



/* シンドローム計算の名残
for(i=1;i<0b110000000000000;i++){
if(itob(i,u)<3){
	for(j=0;j<8;j++){
		c=(G[0]^i)&Ht[j];
		printf("%u",itob(c,u)%2);
			}
		printf(" %b\n",i);
		}
	}
*/

}



/* ビット逆転 */
void rev(unsigned int n)
{
	char s;
	unsigned short r=31,count=0;
	unsigned int k=0,o,p;

	while(n>0){
		o=(n<<31);
		p=31-r;
		k=k|(o>>p);
count++;
		n=(n>>1);
		r--;
	}
count=32-count;
 k=(k>>count);
printf("%b\n",k);
printf("%d\n",k);

}


unsigned int r2r(unsigned int n,unsigned int r)
{
/* Let n is 16-bit unsigned integer */
while(r>0){
	n=(n>>1)|(n<<15);
	r--;
	}
return n;

}


unsigned rstbit(unsigned int n,int p,int q)
{
	return (n & ((~0 << (p+1)) | ~(~0 << (p-q+1))));
}


unsigned int bitget(unsigned int n,int p,int q)
{
	return ((n >> (p-q+1)) & ~(~0 << q));
}




/* ビット位置計算？ */
unsigned int testbit(unsigned int x)
{
unsigned char i,j,l;
unsigned int c=0,
b[15]={
0b100000000000000,
0b10000000000000,
0b1000000000000,
0b100000000000,
0b10000000000,
0b1000000000,
0b100000000,
0b10000000,
0b1000000,
0b100000,
0b10000,
0b1000,
0b100,
0b10,
1
};

l=0;
if(x>b[0]-1){ x=x-b[0]; l++; }
if(x>b[1]-1){ x=x-b[1]; l++; }
if(x>b[2]-1){ x=x-b[2]; l++; }
if(x>b[3]-1){ x=x-b[3]; l++; }
if(x>b[4]-1){ x=x-b[4]; l++; }
if(x>b[5]-1){ x=x-b[5]; l++; }
if(x>b[6]-1){ x=x-b[6]; l++; }
if(x>b[7]-1){ x=x-b[7]; l++; }
if(x>b[8]-1){ x=x-b[8]; l++; }
if(x>b[9]-1){ x=x-b[9]; l++; }
if(x>b[10]-1){ x=x-b[10]; l++; }
if(x>b[11]-1){ x=x-b[11]; l++; }
if(x>b[12]-1){ x=x-b[12]; l++; }
if(x>b[13]-1){ x=x-b[13]; l++; }
if(x>b[14]-1){ x=x-b[14]; l++; }
if(x>b[15]-1){ x=x-b[15]; l++; }
return l%2;



/*
for(i=0;i<7;i++){
	for(j=0;j<8;j++){
	c= G[i]&HT[j];
	 printf("%b ",c); 


 printf("%b_%b ",c,c%2); 
printf("\n");
}
printf("\n");
}
*/

}

/* 多項式の連続する解を求める？ */
unsigned char kon(unsigned char x)
{
	unsigned char m[6],i,l[4];

	l[0]=gf[mlt(mlt(x,x),mlt(x,x))];
	l[1]=gf[mlt(mlt(x,x),x)];
	l[2]=gf[mlt(x,x)];
	l[3]=gf[mlt(l[1],l[2])];

m[0]=1^gf[x]^l[0];
m[1]=1^gf[x]^l[2]^l[1]^l[0];
m[2]=1^gf[x]^l[2];
m[3]=1^l[1]^l[0];

/*
	m[0]=l[3]^l[2]^1;
	m[1]=l[3]^l[1]^1;
	m[2]=l[3]^l[1]^l[2]^gf[x]^1;
	m[3]=l[3]^l[0]^l[2]^gf[x]^1;
	m[4]=l[3]^l[0]^l[1]^gf[x]^1;
	m[5]=l[3]^l[0]^l[1]^l[2]^gf[x]^1;
*/

if(m[0]==0)
printf("m0= %d\n",x);
if(m[1]==0)
printf("m1= %d\n",x);
if(m[2]==0)
printf("m2= %d\n",x);
if(m[3]==0)
printf("m3= %d\n",x);
/*
if(m[4]==0)
printf("m4= %d\n",x);
if(m[5]==0)
printf("m5= %d\n",x);
*/

}


/* 積による暗号化
while((c=fgetc(fp)) !=EOF){
c=seki(g,c)^z[rand()%29];
i=(c>>8);
*/
/* fputc(i,fo);  上位ビット出力 */
/* i=rstbit(c,15,8); 上位ビットリセット */
/* fputc(i,fo); 下位ビット出力 */
/* } */


/* 復元 メンドクセー 
while((c=fgetc(fp)) !=EOF){
if(k==0)
i=(c<<8);
k++;
if(k==2){
j=i+c;
i=(j^pd(j,h));
j=(i>>8);
fputc(j,fo);
j=rst(i,15,8);
fputc(j,fo);
}
}
*/



/* 以下 P-PKS としての性能調査 */
void genz()
{
int i,j,k[3][1365],count[3];
char t[23];


for(i=0;i<3;i++)
count[i]=0;

for(i=0;i<0b111100000000000;i++){
if(itob(i,t)==2)
k[0][count[0]++]=i;
if(itob(i,t)==3)
k[1][count[1]++]=i;
if(itob(i,t)==4)
k[2][count[2]++]=i;
}
for(i=0;i<3;i++){
for(j=0;j<count[i];j++)
printf("%d,",k[i][j]);
printf("\n");
}

}



void ve()
{
int i,j,e,k,b[256];
char t[16],f;


for(i=0;i<256;i++)
b[i]=0;

for(j=0b100000000000000;j<0b111111111111111;j++){
e=0;
f=0;
	if(itob(j,t)==7){
		for(i=0;i<8;i++)
		e=(e<<1)+we(Ht[i]&j);
		for(k=0;k<256;k++){
			if(c[k]==e){
			/* printf("%d,%b\n",e,j); */
				if(b[k]==0){
					b[k]=1;
					printf("%d,%b\n",e,j);
				}

			}
		}
	}
}

}



void ppks()
{
int i,j,k;
static char m[72]={1,2,3,4,5,6,7,8,9,'0',
		'a','b','c','d','e','f','g','h','i','j','k','l',
		'm','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C',
		'D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T',
		'U','V','W','X','Y','Z','!','#','$','%','&','(',')','-','=','^'},
		*hh[72]={
"000000100010111",
"000001000101110",
"000001100111001",
"000010001011100",
"000010101001011",
"000011001110010",
"000011101100101",
"000100010111000",
"000100110101111",
"011001110010000", /* 0 */
"110011000110111", /* a */
"110010100001110", /* b */
"110010000011001", /* c */
"110001101111100", /* d */
"110001001101011", /* e */
"110000101010010", /* f */
"110000001000101", /* g */
"110111110011000", /* h */
"110111010001111", /* i */
"110110110110110", /* j */
"110110010100001", /* k */
"110101111000100", /* l */
"110101011010011", /* m */
"110100111101010", /* n */
"110100011111101", /* o */
"111011001010000", /* p */
"111011101000111", /* q*/
"111010001111110", /*r*/
"111010101101001", /*s*/
"111001000001100", /*t*/
"111001100011011", /*u*/
"111000000100010", /*v*/
"111000100110101", /*w*/
"111111011101000", /*x*/
"111111111111111", /*y*/
"111110011000110", /* z*/
"100010011010111", /* A*/
"100011111101110", /* B*/
"100011011111001", /* C*/
"100000110011100", /* D*/
"100000010001011", /* E*/
"100001110110010", /* F*/
"100001010100101", /* G*/
"100110101111000", /* H*/
"100110001101111", /* I*/
"100111101010110", /* J*/
"100111001000001", /* K*/
"100100100100100", /* L*/
"100100000110011", /* M*/
"100101100001010", /* N*/
"100101000011101", /* O*/
"101010010110000", /* P*/
"101010110100111", /* Q*/
"101011010011110", /* R*/
"101011110001001", /* S*/
"101000011101100", /* T*/
"101000111111011", /* U*/
"101001011000010", /* V*/
"101001111010101", /* W*/
"101110000001000", /* X*/
"101110100011111", /* Y*/
"101111000100110", /* Z*/
"010001111110111", /* !*/
"010000111011001", /* #*/
"010011010111100", /* $*/
"010011110101011", /* %*/
"010010010010010", /* &*/
"010101001011000", /* (*/
"010101101001111", /* )*/
"010111100010011", /*-*/
"011111001100011", /* =*/
"101101001111010" /* ^*/
};


for(i=0;i<72;i++){
for(j=0;j<29;j++)
printf("%u\n",strtoul(hh[i],(char **)NULL,2)^z1[j]);
printf("\n");
}



/*
for(i=0;i<72;i++){
for(j=0;j<15;j++)
printf("%d",we(strtoul(GT[j],(char **)NULL,2)&m[i]));
printf(" %c\n",m[i]);
}
*/


}


